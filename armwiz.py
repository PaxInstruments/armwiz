#!/usr/bin/env python3

#                         ____
#                       .'* *.'
#                    __/_*_*(_
#                   / _______ \
#                  _\_)/___\(_/_
#                 / _((\- -/))_ \
#                 \ \())(-)(()/ /
#                  ' \(((()))/ '
#                 / ' \)).))/ ' \
#                / _ \ - | - /_  \
#               (   ( .;''';. .'  )
#               _\"__ /    )\ __"/_
#                 \/  \   ' /  \/
#                  .'  '...' ' )
#                   / /  |  \ \
#                  / .   .   . \
#                 /   .     .   \
#                /   /   |   \   \
#              .'   /    b    '.  '.
#          _.-'    /     Bb     '-. '-._
#      _.-'       |      BBb       '-.  '-.
#     (__________/\____.dBBBb.________)____)
#  █████╗ ██████╗ ███╗   ███╗██╗    ██╗██╗███████╗
# ██╔══██╗██╔══██╗████╗ ████║██║    ██║██║╚══███╔╝
# ███████║██████╔╝██╔████╔██║██║ █╗ ██║██║  ███╔╝ 
# ██╔══██║██╔══██╗██║╚██╔╝██║██║███╗██║██║ ███╔╝  
# ██║  ██║██║  ██║██║ ╚═╝ ██║╚███╔███╔╝██║███████╗
# ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝     ╚═╝ ╚══╝╚══╝ ╚═╝╚══════╝

# Notes
# =======
# Files that go in the top level project directory:
#   TODO main.c
#   TODO Makefile
#   Done STM32CubeF1/Drivers/CMSIS/Device/ST/STM32F1xx/Source/Templates/gcc/startup_stm32f103xe.s
#   Done STM32CubeF1/Drivers/CMSIS/Device/ST/STM32F1xx/Source/Templates/gcc/linker/STM32F103XE_FLASH.ld
#   TODO The config file
#   TODO STM32CubeF1/Drivers/CMSIS/Device/ST/STM32F1xx/Source/Templates/system_stm32f1xx.c

#   TODO hello/libraries/STM32CubeF1/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h

## Project TODO List
# TODO Function copying the linker script should copy the correct linker script.
# TODO Add a function to pull in the desired submodules as they are needed.
# TODO Make git repo initilization command line option
# TODO If git is not present, do not initialize a git repo
# TODO Implement a spinner to display while each library is being copied
# TODO Generate the project in /tmp/<projectname>. Then mv the directory to
#      the desiginated location only upon successful completition. This is 
#      safter than using an rm command. It also works for when armwiz fails 
#      and cannot itself remove the borked directory.
# TODO Make the cores, boards, etc. use a better system than just declaring
#      each item as a variable. This seems wasetful. We should use something
#      which allows us to load into memory only the items that are being.
#      used. Then we can read from an arbitrarily large configuration file
#      containing all the information.
# TODO Make a tool that can be deployed within a project to give the project
#      some armz functionality. This would be handy for changing which target
#      processor is used or which which libraries are loaded. The armwiz project
#      can just be an empty project generated by itself.
# TODO Make armwiz capable of running form any directory. All tasks are done
#      from the current directory.
# TODO Make function to add a module into the armwiz git repo
# TODO Make function to checkout the latest version or a specified version of 
#      each library. Maybe have an entry in the libraries.config file
# TODO Function to generate a README file. Cat in details about the project
#      configuration, git versions, etc..
# TODO Function to generate linker scripts. It would be nice if this functionality
#      could be used independently of the rest of armwiz.
# TODO Function to download specific libraries from the libraries list without
#      necessarily including them in a project. That is the workaround now.
# TODO List the download status of each library.
# TODO Project generator will make a bare ARM project that does not use any
#      pripherial libraries. Just i++ and use a debugger to view it.
# TODO Add function to download and compile the arm-none-eabi toolchain
# TODO Figure out a way to include a toolchain or download a toolchain with
#      armwiz.
# TODO Function to generate the Makefile
# TODO Reach parity with the code that CubeMX generates. I should output
#      the same files.
# TODO If armwiz is pointed to an existing project, it should add any
#      specified libraries. Directly use git submodule add ...

## Library-specific TODO List
# TODO FreRTOS: Generate FreeRTOSConfig.h
# TODO Make FreeRTOS checkout the most recent version from the tags

# Hello. I am armwiz, the most advanced ARM project generator. With
# my software capabilities at your command you are among the most 
# powerful embedder ARM wizards in the universe. Use your new 
# powers wisely. -armwiz
#


# TODO: Add appropriate information to docstring.
"""
Armwiz docstring.
"""
## Import standard libraries
from subprocess import call
import os
import sys
import errno
import argparse
import configparser
import fileinput

## Standard Python header information
__author__ = "Charles Edward Pax"
__copyright__ = "Copyright 2016, Pax Instruments LLC"
__date__ = "2016"
__credits__ = ["Charles Pax"]
# TODO Add a proper license header
__license__ = "GPL"
__version__ = "0.0.1"
__maintainer__ = "Charles Pax"
__email__ = "charles.pax@gmail.com"
__status__ = "Development"

#######################
## Class definitions ##
#######################

class Manufacturer(object):
	# TODO Add appropriate docstring
	"""The manufacturer of an object"""
	def __init__(self,item_type,proper_name,website_url):
		self.item_type = item_type
		self.proper_name = proper_name
		self.website_url = website_url
		
class Core(object):
	# TODO Add appropriate docstring
	"""The MCU core designed by ARM."""
	def __init__(self,item_type,proper_name,chip_family,architecture,manufacturer,gcc_flag_mcpu):
		self.item_type = item_type
		self.proper_name = proper_name
		self.chip_family = chip_family
		self.architecture = architecture
		self.manufacturer = manufacturer
		self.gcc_flag_mcpu = gcc_flag_mcpu

class Target(object):
	# TODO Add appropriate docstring
	"""The target for which armwiz will generate a project. This could be
	a development board or just an MCU."""
	def __init__(self,item_type,proper_name,mcu,cli_argument,core,manufacturer,short_description,long_description,website_url):
		self.item_type = item_type
		self.proper_name = proper_name
		self.mcu = mcu
		self.cli_argument = cli_argument
		self.core = core
		self.manufacturer = manufacturer
		self.short_description = short_description
		self.long_description = long_description
		self.website_url = website_url

class Library(object):
	"""Libraries in git."""
	def __init__(self,item_type,proper_name,cli_argument,short_description,long_description,git_name,git_url,website_url):
		self.item_type = item_type
		self.proper_name = proper_name
		self.cli_argument = cli_argument
		self.short_description = short_description
		self.long_description = long_description
		self.git_name = git_name
		self.git_url = git_url
		self.website_url = website_url
		# TODO The lines below should to into a function and not as a property of the object
		# self.libTargetDir='{0}/{1}'.format('libraries',self.gitName)
		# self.libSourceDir='{0}/{1}'.format('libraries',self.gitName)

##########################
## Function definitions ##
##########################
def printWizard():
	# TODO Add appropriate docstring
	"""Prints the wizard and header."""
	print("                             ____                   ")
	print("                          .'* *.'                   ")
	print("                       __/_*_*(_                    ")
	print("                      / _______ \                   ")
	print("                     _\_)/___\(_/_                  ")
	print("                    / _((\- -/))_ \                 ")
	print("                    \ \())(-)(()/ /                 ")
	print("                     ' \(((()))/ '                  ")
	print("                    / ' \)).))/ ' \                 ")
	print("                   / _ \ - | - /_  \                ")
	print("                  (   ( .;''';. .'  )               ")
	print("                  _\\\"__ /    )\ __\"/_            ")
	print("                    \/  \   ' /  \/                 ")
	print("                     .'  '...' ' )                  ")
	print("                      / /  |  \ \                   ")
	print("                     / .   .   . \                  ")
	print("                    /   .     .   \                 ")
	print("                   /   /   |   \   \                ")
	print("                 .'   /    b    '.  '.              ")
	print("             _.-'    /     Bb     '-. '-._          ")
	print("         _.-'       |      BBb       '-.  '-.       ")
	print("        (__________/\____.dBBBb.________)____)      ")

def printHeader():
	# TODO Add appropriate docstring
	"""Prints the header"""
	print("     █████╗ ██████╗ ███╗   ███╗██╗    ██╗██╗███████╗")
	print("    ██╔══██╗██╔══██╗████╗ ████║██║    ██║██║╚══███╔╝")
	print("    ███████║██████╔╝██╔████╔██║██║ █╗ ██║██║  ███╔╝ ")
	print("    ██╔══██║██╔══██╗██║╚██╔╝██║██║███╗██║██║ ███╔╝  ")
	print("    ██║  ██║██║  ██║██║ ╚═╝ ██║╚███╔███╔╝██║███████╗")
	print("    ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝     ╚═╝ ╚══╝╚══╝ ╚═╝╚══════╝")
	print("                                      version",__version__ )

def parseArguments():
	# TODO Make all the library options use a simple '-l' flag. The
	#      flag will append that library to the list. A later unction will
	#      iterate through the list, deploying each library.
	# TODO Add appropriate docstring
	"""Parses command line arguments. Returns array."""
	parser = argparse.ArgumentParser(
		description='Generate a template embedded ARM project.',
		# TODO Put 'armwiz' into the standard program header informatin
		epilog="armwiz {}".format(__date__))
	parser.add_argument('-p','--projectname',
		help='Specify project name via -p <projectname>',
		metavar="<projectname>",
		required=False)
	parser.add_argument('-t','--targetname',
		help='Specify target microcontroller or processor via -t <targetname>',
		metavar="<targetname>",
		required=False)
	parser.add_argument('-l','--libraryname',
		help='Specify a library to include via -l <libraryname>',
		metavar="<libraryname>",
		action="append",
		required=False)
	parser.add_argument('-L',
		help='List all libraries available to the -l, --libraryname argument',
		action="store_true",
		required=False)
	parser.add_argument('-T',
		help='List all targets available to the -t, --targetname argument',
		action="store_true",
		required=False)
	parser.add_argument('-w','--wizard',
		help='Print the wizard',
		action="store_true",
		required=False)
	parser.add_argument('-v','--verbose',
		help='Print extra information to the terminal',
		action="store_true",
		required=False)
	parser.add_argument('-q','--quite',
		help='Suppress terminal message as best we can',
		action="store_true",
		required=False)
	parser.add_argument('--version',
		version='%(prog)s {version}'.format(version=__version__),
		action='version')
	return parser

def makePath(paths):
	"""Create a directory path from a string or list of strings and return True.
	Usage:
		makePath('<directory>')
		makePath(['<directory 1>','<directory 2>',...,'<directory n>'])
	Example:
	>>> makePath(['temp/dir1','temp/hello/dir2'])
	True
	$ tree temp/
	temp/
	├── dir1
	└── hello
	    └── dir2
	"""
	try:
		for entry in paths:
			if not type(entry) is str:
				raise TypeError("The type for each pasdfsdfth must be a string. type({}) gives {}".format(entry,type(entry)))
		except TypeError:
			raise TypeError("The type for each path must be a string. type({}) gives {}".format(entry,type(entry)))
	if type(paths) is str:
		try:
			os.makedirs(paths)
		except FileExistsError:
			print('hello')
			pass
	elif type(paths) is list:
		for path in paths:
			makePath(path)
	else:
		raise TypeError("Value for each path must be a string or a list of strings. {} is not a string.".format(path))
	return True

def makeProjectTree(root, paths):
	""" Create a directory tree consisting of a root directory and sub directories.
	Usage:
		makeProjectTree(<projectname>,<list of paths>)

	Example:
	>>> makeProjectTree('projectname',['subDir1','subDir2'])
	$ tree # Executed in terminal
	.
	└── projectname
	    ├── subDir1
	    └── subDir2
	"""
	try:
		assert type(root) is str
	except:
		raise TypeError("Value for <root directory> must be a string. type({}) gives {}".format(root,type(root)))
	try:
		makePath(root)
	except FileExistsError:
		raise FileExistsError("The directory {} already exists.".format(root))
	if type(paths) is str:
		try:
			makePath("{}/{}".format(root,paths))
		except FileExistsError:
			pass
		except:
			raise
	elif type(paths) is list:
		for path in paths:
			try:
				makePath("{}/{}".format(root,path))
			except:
				raise
	return True

## Some quick test code 
# projectTreeTemplate = [
# 	'binary',
# 	'include',
# 	'libraries',
# 	'source',
# 	'tools',
# 	'.git/modules/libraries']
# makeProjectTree('hello',projectTreeTemplate)


def deployMakefile(arguments):
	"""
	# Generate the Makefile
	# Takes <projectname> as argument
	"""
	# TODO Generate Makefile from template
	# TODO Try to make a Makefile that can be used regardless of which libraries
	#      are have been copied. Maybe have one long Makefile with rules for
	#      compilaiton based on which libraries are present in the libraries directory.
	#      Each library will have a .git file we can look at.

def deployExample(arguments):
	"""
	Generate the Makefile
	Takes <projectname> as argument
	"""
	# TODO Generate examples. Modify based on configuration for appropriate LEDs etc.
	# TODO Made an example file specfically for each board and configuration. The
	#      examples must be tailored rather than generated. Generating them on the
	#      fly would be unweildy.
	# TODO Make a directory with a bunch of different examples.

def deployLibrary(projectname,library):
	"""Deploy a library class object"""
	print('Copying {} libraries... '.format(library.name), end="")
	sys.stdout.flush()
	makePath("{0}/{1}".format(projectname,library.libTargetDir))
	try:
		# TODO Verify that the git code is actually downloaded. Look for .git directory.
		assert os.path.exists(library.libSourceDir) == True
	except:
		print('Error')
		print('The source library directory does not exist.')
		exit()
	try:
		call('rsync -ac {}/ {}/{}/'.format(library.libSourceDir,projectname,library.libTargetDir),shell=True)
	except:
		print('ERROR using rsync to copy {}'.format(library.name))
	try:
		call('rsync -ac .git/modules/{}/ {}/.git/modules/{}/'.format(library.libSourceDir,projectname,library.libTargetDir),shell=True)
		moduleFile = open('{0}/.gitmodules'.format(projectname), 'a')
		moduleFile.write("\n[submodule \"{0}\"]\n".format(library.libTargetDir))
		moduleFile.write("\tpath = {0}\n".format(library.libTargetDir))
		moduleFile.write("\turl = {0}\n".format(library.gitURL))
		moduleFile.close()
		print('Okay')
		sys.stdout.flush()
	except:
		print('ERROR copying')
		exit()
	try:
		print('Adding {} to git... '.format(library.name),end='')
		sys.stdout.flush()
		call('cd {0}; git add .gitmodules; git add {1}; git submodule init -q '.format(projectname,library.libTargetDir),shell=True)
	except:
		print('Error')
		print("Error initializing submodule")
	try:
		sys.stdout.flush()
		call("cd {0}; git commit -qam 'armwiz added {1}'".format(projectname,library.name),shell=True)
		print('Okay')
		sys.stdout.flush()
	except:
		pritn('Error')
		print('Error Committing changes')

def is_valid_file(parser, arg):
    if not os.path.exists(arg):
        parser.error("The file %s does not exist!" % arg)
    else:
        return open(arg, 'r')  # return an open file handle

def main():
	# TODO Add appropriate docstring
	"""The main program loop"""
	parser = parseArguments()
	arguments = parser.parse_args()


	if arguments.wizard == True:
		try:
			printWizard()
		except:
			Print('Mysterious wizardly error. Return from whence you came!')
			raise

	if arguments.L == True:
		try:
			libraryConfigFileName = 'libraries.config'
			libraryConfig = configparser.ConfigParser()
			libraryConfig.read('libraries.config')
			assert len(libraryConfig.read(libraryConfigFileName)) !=0
			# TODO Verify file is valid
			# TODO Make a function for checking file presence and validity
		except AssertionError:
			# TODO Give an option to the use on how to fix this.
			print("File '{0}'' is empty or missing.".format(libraryConfigFileName))
			exit()
		except:
			raise
			exit()
		print('  -l <library>  Library Description')
		print('  ------------  --------------------------------')
		for library in libraryConfig:
			try:
				# TODO Generate the righ justification value by looking at the config file
				print('  {:<12}  {}'.format(libraryConfig.get(library,'option'),libraryConfig.get(library,'short_description')))
			except configparser.NoOptionError:
				pass
			except:
				raise
		exit()

	if arguments.projectname == None:
		parser.print_help()


	# Load the libraries configuration file
	if arguments.library != None:
		try:
			libraryConfigFileName = 'libraries.config'
			libraryConfig = configparser.ConfigParser()
			libraryConfig.read('libraries.config')
			assert len(libraryConfig.read(libraryConfigFileName)) !=0
			# TODO Verify file is valid
			# TODO Make a function for checking file presence and validity
		except AssertionError:
			# TODO Give an option to the use on how to fix this.
			print("File '{0}'' is empty or missing.".format(libraryConfigFileName))
			exit()
		except:
			raise
			exit()
		# Verify all libraries are valid options
		for option in arguments.library:
			try:
				libraryConfig.get('{0}'.format(option),'option')
			except configparser.NoOptionError :
				# TODO Give an option to the use on how to fix this.
				print('The library.config entry {0} has malformatted options.'.format(option))
				exit()
			except configparser.NoSectionError :
				# TODO Give an option to the use on how to fix this.
				print("You chose a library called '{0}', but this is not a valid library option. Run 'armwiz -L' for a list of available libraries.".format(option))
				exit()
			except:
				raise
				exit()

	# If we get to this point, all the library options are valid

	# TODO Add a function here to confirm all the options are valid
	# TODO Add a function here to determine if the project can be made

	if arguments.projectname:
		try:
			# TODO Verify the project name is valid
			makeProjectDirectoryTree(arguments)
		except:
			# TODO makeProjectDirectoryTree() should actually give a proper error
			print("The project '{0} could no be created. It probably already exists!".format(arguments.projectname))

	if arguments.library != None:
		for option in arguments.library:
			optionName = libraryConfig.get(option,'option')
			thisGitName = libraryConfig.get(option,'gitName')
			thisGitURL = libraryConfig.get(option,'gitURL')
			thisLibrary = Library(optionName,thisGitName,thisGitURL)
			try:
				deployLibrary(arguments.projectname,thisLibrary)
			except:
				print("Oops! I couldn't copy {0}".format(option))
				raise

	# This is specific for the STM32F103 board I'm using. This is temporary code
	try:
		print('Copying template files... ',end='')
		copySTM103Files(arguments.projectname)
		print('Okay')
	except:
		raise

if __name__ == "__main__":
	# TODO Read about python file structure
	#      https://www.artima.com/weblogs/viewpost.jsp?thread=4829
	main()














